/*
**    Generated by Code_Generation toolbox of Xcos with scilab-2024.0.0
**    Date :13-Dec-2023
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
extern void **junk_code_block_outtbptr;
extern char input[50],output[50];
FILE *fprr = NULL, *fprw = NULL;
/*----------------------------------------  External events handling function */
void junk_code_events(int *nevprt,double *t)
{
/*  set next event time and associated events ports
 *  nevprt has binary expression b1..b0 where bi is a bit
 *  bi is set to 1 if an activation is received by port i. Note that
 *  more than one activation can be received simultaneously
 *  Caution: at least one bi should be equal to one */


/* definition of the step time  */
    *t = *t + 0.1;
}
/*
**    Generated by Code_Generation toolbox of Xcos with scilab-2024.0.0
**    Date : 13-Dec-2023
*/

/*---------------------------------------- Actuators */
void junk_code_actuator(int *flag, int *nport, int *nevprt, double *t, void *u, int *nu1, int *nu2, int *ut, int flag1)
     /*
      * To be customized for standalone execution
      * flag  : specifies the action to be done
      * nport : specifies the  index of the Super Bloc
      *         regular input (The input ports are numbered
      *         from the top to the bottom )
      * nevprt: indicates if an activation had been received
      *         0 = no activation
      *         1 = activation
      * t     : the current time value
      * u     : the vector inputs value
      * nu1   : the input size 1
      * nu2   : the input size 2
      * ut    : the input type
      * flag1 : learn mode (0 from terminal,1 from input file
      */
{
  int j,k,l;
  if (flag1 == 0){
  switch (*nport) {
  case 1 :/* Port number 1 ----------*/
    /* skeleton to be customized */
      switch (*flag) {
      /* OutputUpdate (*flag==1) will be called on each iteration */
      case 1 :
        /*if(*nevprt>0) { get the input value */
          switch (*ut) {
          case 10 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %f \n", \
                       *t, k, l, *nport,*((double *) u+(k+l*(*nu1))));
              }
            }
            break;
  
          case 11 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %f,%f \n", \
                       *t, k, l, *nport,*((double *) u+(k+l*(*nu1))),*((double *) u+((*nu1)*(*nu2)+k+l*(*nu1))));
              }
            }
            break;
  
          case 81 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %i \n", \
                       *t, k, l, *nport,*((char *) u+(k+l*(*nu1))));
              }
            }
            break;
  
          case 82 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %hd \n", \
                       *t, k, l, *nport,*((short *) u+(k+l*(*nu1))));
              }
            }
            break;
  
          case 84 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %ld \n", \
                       *t, k, l, *nport,*((long *) u+(k+l*(*nu1))));
              }
            }
            break;
  
          case 811 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %d \n", \
                       *t, k, l, *nport,*((unsigned char *) u+(k+l*(*nu1))));
              }
            }
            break;
  
          case 812 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %hu \n", \
                       *t, k, l, *nport,*((unsigned short *) u+(k+l*(*nu1))));
              }
            }
            break;
  
          case 814 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %lu \n", \
                       *t, k, l, *nport,*((unsigned long *) u+(k+l*(*nu1))));
              }
            }
            break;
          }
        /*} */
        break;
      case 4 : /* actuator initialisation */
        /* do whatever you want to initialize the actuator */
        break;
      case 5 : /* actuator ending */
        /* do whatever you want to end the actuator */
        break;
      }
  break;
  case 2 :/* Port number 2 ----------*/
    /* skeleton to be customized */
      switch (*flag) {
      /* OutputUpdate (*flag==1) will be called on each iteration */
      case 1 :
        /*if(*nevprt>0) { get the input value */
          switch (*ut) {
          case 10 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %f \n", \
                       *t, k, l, *nport,*((double *) u+(k+l*(*nu1))));
              }
            }
            break;
  
          case 11 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %f,%f \n", \
                       *t, k, l, *nport,*((double *) u+(k+l*(*nu1))),*((double *) u+((*nu1)*(*nu2)+k+l*(*nu1))));
              }
            }
            break;
  
          case 81 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %i \n", \
                       *t, k, l, *nport,*((char *) u+(k+l*(*nu1))));
              }
            }
            break;
  
          case 82 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %hd \n", \
                       *t, k, l, *nport,*((short *) u+(k+l*(*nu1))));
              }
            }
            break;
  
          case 84 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %ld \n", \
                       *t, k, l, *nport,*((long *) u+(k+l*(*nu1))));
              }
            }
            break;
  
          case 811 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %d \n", \
                       *t, k, l, *nport,*((unsigned char *) u+(k+l*(*nu1))));
              }
            }
            break;
  
          case 812 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %hu \n", \
                       *t, k, l, *nport,*((unsigned short *) u+(k+l*(*nu1))));
              }
            }
            break;
  
          case 814 :
            for (l=0;l<*nu2;l++) {
              for (k=0;k<*nu1;k++) {
                printf("Actuator: time=%f, u(%d,%d) of actuator %d is %lu \n", \
                       *t, k, l, *nport,*((unsigned long *) u+(k+l*(*nu1))));
              }
            }
            break;
          }
        /*} */
        break;
      case 4 : /* actuator initialisation */
        /* do whatever you want to initialize the actuator */
        break;
      case 5 : /* actuator ending */
        /* do whatever you want to end the actuator */
        break;
      }
  break;
  }
  }
  else if (flag1 == 1) {
    if (*flag == 4 && *nport == 1) {
      fprw=fopen(output,"wt");
      if( fprw == NULL ) {
        printf("Error opening file: %s\n", output);
        return;
        }
    }
    else if (*flag == 2 /*&& *nevprt>0*/ ) {
    fprintf(fprw,"%f " \
                 "%f %f " \
                 "%f \n", \
                 *t,
                 *(((double *)(junk_code_block_outtbptr+1))+0), *(((double *)(junk_code_block_outtbptr+1))+1),
                 *(((double *)(junk_code_block_outtbptr+3))+0));
    }
    else if (*flag == 5 && *nport == 1) {
      fclose(fprw);
    }
  }
}
/*---------------------------------------- Sensor */
void junk_code_sensor(int *flag, int *nport, int *nevprt, double *t, void *y, int *ny1, int *ny2, int *yt, int *flag1)
     /*
      * To be customized for standalone execution
      * flag  : specifies the action to be done
      * nport : specifies the  index of the Super Bloc
      *         regular input (The input ports are numbered
      *         from the top to the bottom )
      * nevprt: indicates if an activation had been received
      *         0 = no activation
      *         1 = activation
      * t     : the current time value
      * y     : the vector outputs value
      * ny1   : the output size 1
      * ny2   : the output size 2
      * yt    : the output type
      * flag1 : learn mode (0 from terminal,1 from input file
      */
{
  int j,k,l;
  double temps;
  if (flag1 == 0) {
    switch (*flag) {
    case 1 : /* set the output value */
      printf("Require outputs of sensor number %d\n", *nport);
      printf("time is: %f\n", *t);
      printf("sizes of the sensor output is: %d,%d\n", *ny1,*ny2);
      switch (*yt) {
      case 10 :
        printf("type of the sensor output is: %d (double) \n", *yt);
        puts("Please set the sensor output values");
        for (l=0;l<*ny2;l++) {
          for (k=0;k<*ny1;k++) {
            printf("y(%d,%d) : ",k,l);
            scanf("%lf", (double *) y+(k+l*(*ny1)));
          }
        }
        break;

      case 11 :
        printf("type of the sensor output is: %d (complex) \n", *yt);
        puts("Please set the sensor output values");
        for (l=0;l<*ny2;l++) {
          for (k=0;k<*ny1;k++) {
            printf("y(%d,%d) real part : ",k,l);
            scanf("%lf", (double *) y+(k+l*(*ny1)));
            printf("y(%d,%d) imag part : ",k,l);
            scanf("%lf", (double *) y+((*ny1)*(*ny2)+k+l*(*ny1)));
          }
        }
        break;

      case 81 :
        printf("type of the sensor output is: %d (char) \n", *yt);
        puts("Please set the sensor output values");
        for (l=0;l<*ny2;l++) {
          for (k=0;k<*ny1;k++) {
            printf("y(%d,%d) : ",k,l);
            scanf("%i", (char *) y+(k+l*(*ny1)));
          }
        }
        break;

      case 82 :
        printf("type of the sensor output is: %d (char) \n", *yt);
        puts("Please set the sensor output values");
        for (l=0;l<*ny2;l++) {
          for (k=0;k<*ny1;k++) {
            printf("y(%d,%d) : ",k,l);
            scanf("%hd", (short *) y+(k+l*(*ny1)));
          }
        }
        break;

      case 84 :
        printf("type of the sensor output is: %d (long) \n", *yt);
        puts("Please set the sensor output values");
        for (l=0;l<*ny2;l++) {
          for (k=0;k<*ny1;k++) {
            printf("y(%d,%d) : ",k,l);
            scanf("%ld", (long *) y+(k+l*(*ny1)));
          }
        }
        break;

      case 811 :
        printf("type of the sensor output is: %d (unsigned char) \n", *yt);
        puts("Please set the sensor output values");
        for (l=0;l<*ny2;l++) {
          for (k=0;k<*ny1;k++) {
            printf("y(%d,%d) : ",k,l);
            scanf("%d", (unsigned char *) y+(k+l*(*ny1)));
          }
        }
        break;

      case 812 :
        printf("type of the sensor output is: %d (unsigned short) \n", *yt);
        puts("Please set the sensor output values");
        for (l=0;l<*ny2;l++) {
          for (k=0;k<*ny1;k++) {
            printf("y(%d,%d) : ",k,l);
            scanf("%hu", (unsigned short *) y+(k+l*(*ny1)));
          }
        }
        break;

      case 814 :
        printf("type of the sensor output is: %d (unsigned long) \n", *yt);
        puts("Please set the sensor output values");
        for (l=0;l<*ny2;l++) {
          for (k=0;k<*ny1;k++) {
            printf("y(%d,%d) : ",k,l);
            scanf("%lu", (unsigned long *) y+(k+l*(*ny1)));
          }
        }
        break;

      }
      break;
    case 4 : /* sensor initialisation */
      /* do whatever you want to initialize the sensor */
      break;
    case 5 : /* sensor ending */
      /* do whatever you want to end the sensor */
      break;
    }
  } 
  else if (flag1 == 1) {
    if (*flag == 4 && *nport == 1) {
      fprr=fopen(input,"r");
      if( fprr == NULL ) {
        printf("Error opening file: %s\n", input);
        return;
      }
    }
    else if (*flag == 1) {
    fscanf(fprr,"%lf " \
                "%lf \n", \
                &temps,
                (double *)(junk_code_block_outtbptr+0)+0);
    }
    else if (*flag == 5 && *nport == 1) {
      fclose(fprr);
    }
  }
}
